///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>
///<reference path="lib/collections.ts"/>

/**
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/
module Planner {

    //////////////////////////////////////////////////////////////////////
    // exported functions, classes and interfaces/types

    /**
     * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter.
     * @param interpretations List of possible interpretations.
     * @param currentState The current state of the world.
     * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
     */
    export function plan(interpretations : Interpreter.InterpretationResult[],
      currentState : WorldState) : PlannerResult[] {
        var errors : Error[] = [];
        var plans : PlannerResult[] = [];
        interpretations.forEach((interpretation) => {
            try {
                var result : PlannerResult = <PlannerResult>interpretation;
                result.plan = planInterpretation(result.interpretation, currentState);
                if (result.plan.length == 0) {
                    result.plan.push("That is already true!");
                }
                plans.push(result);
            } catch(err) {
                errors.push(err);
            }
        });
        if (plans.length) {
            return plans;
        } else {
            // only throw the first error found
            throw errors[0];
        }
    }

    export interface PlannerResult extends Interpreter.InterpretationResult {
        plan : string[];
    }

    export function stringify(result : PlannerResult) : string {
        return result.plan.join(", ");
    }

    //////////////////////////////////////////////////////////////////////
    // private functions

     /**
      * The core planner function. The code here is just a template;
      * you should rewrite this function entirely. In this template,
      * the code produces a dummy plan which is not connected to the
      * argument `interpretation`, but your version of the function
      * should be such that the resulting plan depends on
      * `interpretation`.
      *
      *
      * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
      * @param state The current world state.
      * @returns Basically, a plan is a
      * stack of strings, which are either system utterances that
      * explain what the robot is doing (e.g. "Moving left") or actual
      * actions for the robot to perform, encoded as "l", "r", "p", or
      * "d". The code shows how to build a plan. Each step of the plan can
      * be added using the `push` method.
      */

    /*
        State is the Node class used in a*.
        Holds information about the world.
    */
    class State {
        constructor(st : State | WorldState){
            this.stacks = st.stacks.map(x => x.slice());
            this.holding = st.holding;
            this.arm = st.arm;
        };

        stacks: Stack[];

        holding: string;

        arm: number;

        compareTo(other: State) : number {
            return 0;
        }
        toString() : string {
            return collections.makeString(this);
        }
    }

    /*
        PlanGraph is the Graph type used to build a graph that we can use in A*.
        Implements the interface Graph from the file with the same name,
        the functions outgoingEdges & compareNodes is defined and configured to
        the class State.
    */
    class PlanGraph implements Graph<State>{
        objects: { [s:string]: ObjectDefinition; };
        constructor(state : WorldState){this.objects = state.objects;};


        outgoingEdges(state : State) : Edge<State>[] {
            let edges : Edge<State>[] = [];

            if(state.arm > 0) {
                let s = new State(state);
                s.arm--;
                edges.push({from: state, to: s, cost: 1});
            }
            if(state.arm < state.stacks.length-1) {
                let s = new State(state);
                s.arm++;
                edges.push({from: state, to: s, cost: 1});
            }
            if (!state.holding && state.stacks[state.arm] != null) {
                let s = new State(state);
                s.holding = s.stacks[s.arm].pop();
                if (typeof s.stacks[s.arm] === "undefined")
                    s.stacks[s.arm] = [];
                edges.push({from: state, to: s, cost: 1});
            } else if(state.holding) {
                let s = new State(state);
                if (!s.stacks[s.arm])
                    s.stacks[s.arm] = [];
                let fun = Interpreter.filterDst;
                let dstStack = s.stacks[s.arm];
                let src = this.objects[state.holding];
                let dst = this.objects[dstStack[dstStack.length-1]];
                if (dstStack[dstStack.length-1] !== "floor" &&
                    typeof dst !== "undefined" &&  typeof src !== "undefined")
                {
                    if(!fun("ontop",src,dst) && !fun("inside",src,dst)) {
                        s.stacks[s.arm].push(s.holding);
                        s.holding = null;
                        edges.push({from: state, to: s, cost: 1});
                    }
                } else {
                    s.stacks[s.arm].push(s.holding);
                    s.holding = null;
                    edges.push({from: state,
                    to: s,
                    cost: 1});
                }
            }
            return edges;
        }

        compareNodes(a : State, b : State) : number {
            return a.compareTo(b);
        }
    }

    /*
        CheckLit is a function that checks whether the literal is legit in the
        given state or not
    */
    function checkLit(lit : Interpreter.Literal,
     state : State): boolean
    {
        let rel = lit.relation;
        let src : Interpreter.Pos = Interpreter.findPos(lit.args[0],state.stacks);
        let dst : Interpreter.Pos = Interpreter.findPos(lit.args[1],state.stacks);
        let onFloor :boolean;

        if (typeof state.stacks[state.arm] !== "undefined")
            onFloor = (lit.args[1] === "floor" &&
            state.stacks[state.arm][0] === lit.args[0]);
        else
            onFloor = false;

        return onFloor ||
        (rel === "holding" && state.holding === lit.args[0]) || !state.holding && (
        (rel === "inside" && src.x === dst.x && (src.y - 1) === dst.y) ||
        (rel === "ontop" && src.x === dst.x && (src.y - 1) === dst.y) ||
        (rel === "above" && src.x === dst.x && src.y > dst.y) ||
        (rel === "under" && src.x === dst.x && src.y < dst.y) ||
        (rel === "leftof" && src.x < dst.x && src.x > -1) ||
        (rel === "rightof" && src.x > dst.x && dst.x > -1 && src.x < state.stacks.length) ||
        (rel === "beside" && Math.abs(src.x-dst.x) === 1));
    }


    // A* result must be converted to string []
    //TODO SearchResult<Node> to string []
    function interpret(result : SearchResult<State>) : string [] {

        // Only need path?
        let path : State[]  = result.path;

        // The plan that we will return
        let plan : string[] = [];

        // Compares each current state with the previous one and adds the
        // difference (as a string - l,r,p,d) to a list
        for (var i = 0; i < path.length - 1; i++) {
            var currentState : State = path[i];
            var nextState : State = path[i+1];

            if(nextState.arm < currentState.arm)
                plan.push("l");
            else if(nextState.arm > currentState.arm)
                plan.push("r");
            else if(nextState.holding && !currentState.holding)
                plan.push("p");
            else if(!nextState.holding && currentState.holding)
                plan.push("d");
        }
        return plan;
    }

    function planInterpretation(
        interpretation : Interpreter.DNFFormula,
        state : WorldState) : string[]
    {
        let start = new State(state);

        // Select the interpretation with smallest start heuristic
        let hList = interpretation.map(y => Math.min( ...y.map(x => manhattan(x,start))));
        let best = interpretation[hList.indexOf(Math.min.apply(Math,hList))];

        let algorithmResult =
            aStarSearch<State>(
                // Graph
                new PlanGraph(state),

                // State from WorldState
                start,

                // Goal function
                (st : State) => best.every( lit => checkLit(lit, st) ),

                // Heuristsic function
                (n : State) => Math.min( ...best.map(x => manhattan(x,n))),

                // Timeout in seconds
                10
            );
        console.log(algorithmResult.cost)
        return interpret(algorithmResult);
    }




    /* Manhattan distance heuristic function */


    function manhattan (lit : Interpreter.Literal, state : State) : number {

        // If state is the goal state, return 0
        if (checkLit(lit, state))
            return 0;

        // Get the objects id's from the list of arguments
        let [src,dst] = lit.args;

        /*
            If object exist and is not floor then we find the position of object
            otherwise we get a good position on the floor.
        */
        let funPos = (obj : string) => (obj && obj !== "floor") ?
            Interpreter.findPos(obj, state.stacks) : findBestFloorPos();

        // Penalty function used for source object in stacks
        let srcPenalty = (n :number) => 5*n;

        // Penalty function used for destination object in stacks
        let dstPenalty = (n :number) => 4*n;

        let isZero = (n :number) => (n === 0) ? 0 : n-1;

        // The length from arm to object
        let armToObj = (obj : string, pos : Interpreter.Pos) =>
            (obj === state.holding) ? 0 : Math.abs(state.arm - pos.x) ;

        // The cost of uncover an object
        let uncoverObj = (obj : string, pos : Interpreter.Pos, str : string) => {
            // If we are holding an object we at least have to put it down
            if(obj === state.holding){
                return 1;
            }
            else {
                // If source object, use source penalty function
                if(str === "src")
                    return srcPenalty(isZero(state.stacks[pos.x].length - pos.y));
                // If destination object, use destination penalty function
                else
                    return dstPenalty(isZero(state.stacks[pos.x].length - pos.y));
            }
            
        }

        // Merged function for easy use
        let armAndUncover = (obj : string, pos : Interpreter.Pos, str : string) =>
            armToObj(obj,pos) + uncoverObj(obj,pos,str);

        // Find position for source
        let srcPos = funPos(src);

        // If relation is holding we don't need destination
        if (lit.relation === "holding") {
            let res = armAndUncover(src,srcPos,"src");
            console.log(res);
            return res;
        }


        // Find position for destination
        let dstPos = funPos(dst);

        // All the possible results want to know what the difference between src & dst is
        let result :number = (srcPos.x < 0 || dstPos.x < 0) ? 0 : Math.abs(srcPos.x - dstPos.x);

        // Difference in Y and
        if (lit.relation === "inside" || lit.relation === "ontop") {
            result += Math.min(armToObj(src,srcPos),armToObj(dst,dstPos));

            // Are they on the same stack, if so we need not to add, just estimate the cost
            if (srcPos.x === dstPos.x)
                result += Math.max(uncoverObj(src,srcPos,"src"),uncoverObj(dst,dstPos,"dst"));
            else{
                result += uncoverObj(src,srcPos,"src") + uncoverObj(dst,dstPos,"dst");
            }
        }

        else if (lit.relation === "leftof" || lit.relation === "rightof" || lit.relation === "beside")
            result += Math.min(armAndUncover(src,srcPos,"src"), armAndUncover(dst,dstPos,"dst"));

        else if (lit.relation === "above" || lit.relation === "under"){
            result += uncoverObj(src,srcPos,"src") + uncoverObj(dst,dstPos,"dst");
        }

        return result;

        /* ------------- private functions ------------- */


        function findBestFloorPos() : Interpreter.Pos {

            // calculate the cost for each spot on the floor
            let results = state.stacks.map((stack, x) => dstPenalty(stack.length) + Math.abs(x - state.arm));

            // pick the index of the smallest value
            let pos = results.indexOf(Math.min.apply(Math,results));

            // Floor at pos is best, floor is at position 0 of course
            return {x : pos, y : 0};
        }

    }

}
