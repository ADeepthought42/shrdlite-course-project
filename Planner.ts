///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>

/**
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/
module Planner {

    //////////////////////////////////////////////////////////////////////
    // exported functions, classes and interfaces/types

    /**
     * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter.
     * @param interpretations List of possible interpretations.
     * @param currentState The current state of the world.
     * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
     */
    export function plan(interpretations : Interpreter.InterpretationResult[],
      currentState : WorldState) : PlannerResult[] {
        var errors : Error[] = [];
        var plans : PlannerResult[] = [];
        interpretations.forEach((interpretation) => {
            try {
                var result : PlannerResult = <PlannerResult>interpretation;
                result.plan = planInterpretation(result.interpretation, currentState);
                if (result.plan.length == 0) {
                    result.plan.push("That is already true!");
                }
                plans.push(result);
            } catch(err) {
                errors.push(err);
            }
        });
        if (plans.length) {
            return plans;
        } else {
            // only throw the first error found
            throw errors[0];
        }
    }

    export interface PlannerResult extends Interpreter.InterpretationResult {
        plan : string[];
    }

    export function stringify(result : PlannerResult) : string {
        return result.plan.join(", ");
    }

    //////////////////////////////////////////////////////////////////////
    // private functions

    /**
     * The core planner function. The code here is just a template;
     * you should rewrite this function entirely. In this template,
     * the code produces a dummy plan which is not connected to the
     * argument `interpretation`, but your version of the function
     * should be such that the resulting plan depends on
     * `interpretation`.
     *
     *
     * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
     * @param state The current world state.
     * @returns Basically, a plan is a
     * stack of strings, which are either system utterances that
     * explain what the robot is doing (e.g. "Moving left") or actual
     * actions for the robot to perform, encoded as "l", "r", "p", or
     * "d". The code shows how to build a plan. Each step of the plan can
     * be added using the `push` method.
     */

     //TODO Integration with A* search algorithm and the world
        //TODO Define Graph & Node in our world
            //TODO Define Node
                // We call it Node for the simplicity

            //TODO class that implements interface Graph<Node>
            class PlanGraph implements Graph<WorldState>{
                //TODO
                constructor(){};

                //TODO outgoingEdges(node : Node) : Edge<Node>[];
                outgoingEdges(node : WorldState) : Edge<WorldState>[] {
                    let edges : Edge<WorldState>[] = [];
                    // TODO
                    return edges;
                }

                //TODO compareNodes : collections.ICompareFunction<Node>;
                compareNodes : collections.ICompareFunction<WorldState> =
                    (x : WorldState, y : WorldState) : number => {
                        return 0;
                    };
            }

        //TODO Graph function Graph<Node>
            //TODO @Param ?
                // interpretation : Interpreter.DNFFormula,
                // state : WorldState
        function graph() : PlanGraph {
            return null;
        }

        //TODO Start node function
            //TODO @Param ?
                // interpretation : Interpreter.DNFFormula,
                // state : WorldState
        function start() : WorldState {
            return null;
        }

        //TODO Goal function (n:Node) => boolean
            //TODO @Param ?
                // interpretation : Interpreter.DNFFormula,
                // state : WorldState
        function goal() : (n:WorldState) => boolean {
            return (n : WorldState) => {
                return true;
            };
        }

        //TODO Heuristic function (n:Node) => number
            //TODO @Param ?
                // interpretation : Interpreter.DNFFormula,
                // state : WorldState
        function heuristic() : (n:WorldState) => number {
            return (n : WorldState) => {
                return 0;
            };
        }

        //TODO timeout set
            //TODO @Param ?
        function timeout() : number {
            return 10;
        }

    // A* result must be converted to string []
    //TODO SearchResult<Node> to string []
    function interpret(result : SearchResult<WorldState>) : string [] {

        // Only need path?
        let path : WorldState[]  = result.path;

        // The plan that we will return
        let plan : string[] = [];

        for (var i = 0; i < path.length - 1; i++) {
            var cs : WorldState = path[i];
            var ns : WorldState = path[i+1];

            if(ns.arm < cs.arm)
                plan.push("l");
            else if(ns.arm > cs.arm)
                plan.push("r");
            else if(ns.holding && !cs.holding)
                plan.push("p");
            else if(!ns.holding && cs.holding)
                plan.push("d");
            else
                throw "";
        }

        return plan;
    }

    function planInterpretation(
        interpretation : Interpreter.DNFFormula,
        state : WorldState) : string[]
    {
        return interpret(
            aStarSearch<WorldState>(
                // TODO Assign parameters to those that needs it
                graph(),
                start(),
                goal(),
                heuristic(),
                timeout()
            )
        );
    }


    /*
            // This function returns a dummy plan involving a random stack
            do {
                var pickstack = Math.floor(Math.random() * state.stacks.length);
            } while (state.stacks[pickstack].length == 0);
            var plan : string[] = [];

            // First move the arm to the leftmost nonempty stack
            if (pickstack < state.arm) {
                plan.push("Moving left");
                for (var i = state.arm; i > pickstack; i--) {
                    plan.push("l");
                }
            } else if (pickstack > state.arm) {
                plan.push("Moving right");
                for (var i = state.arm; i < pickstack; i++) {
                    plan.push("r");
                }
            }

            // Then pick up the object
            var obj = state.stacks[pickstack][state.stacks[pickstack].length-1];
            plan.push("Picking up the " + state.objects[obj].form,
                      "p");

            if (pickstack < state.stacks.length-1) {
                // Then move to the rightmost stack
                plan.push("Moving as far right as possible");
                for (var i = pickstack; i < state.stacks.length-1; i++) {
                    plan.push("r");
                }

                // Then move back
                plan.push("Moving back");
                for (var i = state.stacks.length-1; i > pickstack; i--) {
                    plan.push("l");
                }
            }

            // Finally put it down again
            plan.push("Dropping the " + state.objects[obj].form,
                      "d");

            return plan;
    */

}
